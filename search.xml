<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Untiy Shader 模糊算子</title>
      <link href="/Unity%20Shader%20%E6%A8%A1%E7%B3%8A%E7%AE%97%E5%AD%90.html"/>
      <url>/Unity%20Shader%20%E6%A8%A1%E7%B3%8A%E7%AE%97%E5%AD%90.html</url>
      
        <content type="html"><![CDATA[<h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/blur"</span></span><br><span class="line">&#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_MainTex (<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">_OutlineSize(<span class="string">"Outline Size"</span>, Range(<span class="number">0</span>, <span class="number">8</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">Tags </span><br><span class="line">&#123; </span><br><span class="line"><span class="string">"RenderType"</span>=<span class="string">"Transparent"</span> </span><br><span class="line"><span class="string">"Queue"</span>=<span class="string">"Transparent"</span></span><br><span class="line">&#125;</span><br><span class="line">LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br><span class="line"></span><br><span class="line">#include <span class="string">"UnityCG.cginc"</span></span><br><span class="line"></span><br><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float4 color : COLOR;</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">float4 color : COLOR;</span><br><span class="line">float4 vertex : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">float4 _MainTex_TexelSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _OutlineSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> step_w;</span><br><span class="line">            <span class="keyword">float</span> step_h;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span> <span class="params">(appdata v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.color = v.color;</span><br><span class="line">o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">fixed4 origin = tex2D(_MainTex, i.uv);</span><br><span class="line">fixed4 albedo = i.color;</span><br><span class="line"></span><br><span class="line">step_w = _MainTex_TexelSize.x * _OutlineSize;</span><br><span class="line">step_h = _MainTex_TexelSize.y * _OutlineSize;</span><br><span class="line"></span><br><span class="line">float2 offset[<span class="number">25</span>] = </span><br><span class="line">&#123;</span><br><span class="line">float2(-step_w*<span class="number">2.0</span>, -step_h*<span class="number">2.0</span>), float2(-step_w, -step_h*<span class="number">2.0</span>),  float2(<span class="number">0.0</span>, -step_h*<span class="number">2.0</span>), float2(step_w, -step_h*<span class="number">2.0</span>), float2(step_w*<span class="number">2.0</span>, -step_h*<span class="number">2.0</span>),</span><br><span class="line">float2(-step_w*<span class="number">2.0</span>, -step_h),     float2(-step_w, -step_h),      float2(<span class="number">0.0</span>, -step_h),     float2(step_w, -step_h),     float2(step_w*<span class="number">2.0</span>, -step_h),</span><br><span class="line">float2(-step_w*<span class="number">2.0</span>, <span class="number">0.0</span>),         float2(-step_w, <span class="number">0.0</span>),          float2(<span class="number">0.0</span>, <span class="number">0.0</span>),         float2(step_w, <span class="number">0.0</span>),         float2(step_w*<span class="number">2.0</span>, <span class="number">0.0</span>),</span><br><span class="line">float2(-step_w*<span class="number">2.0</span>, step_h),      float2(-step_w, step_h),       float2(<span class="number">0.0</span>, step_h),      float2(step_w, step_h),      float2(step_w*<span class="number">2.0</span>, step_h),</span><br><span class="line">float2(-step_w*<span class="number">2.0</span>, step_h*<span class="number">2.0</span>),  float2(-step_w, step_h*<span class="number">2.0</span>),   float2(<span class="number">0.0</span>, step_h*<span class="number">2.0</span>),  float2(step_w, step_h * <span class="number">2.0</span>),   float2(step_w*<span class="number">2.0</span>, step_h*<span class="number">2.0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> kernel[<span class="number">25</span>] = </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0.003765</span>,    <span class="number">0.015019</span>,    <span class="number">0.023792</span>,    <span class="number">0.015019</span>,    <span class="number">0.003765</span>,</span><br><span class="line"><span class="number">0.015019</span>,    <span class="number">0.059912</span>,    <span class="number">0.094907</span>,    <span class="number">0.059912</span>,    <span class="number">0.015019</span>,</span><br><span class="line"><span class="number">0.023792</span>,    <span class="number">0.094907</span>,    <span class="number">0.150342</span>,    <span class="number">0.094907</span>,    <span class="number">0.023792</span>,</span><br><span class="line"><span class="number">0.015019</span>,    <span class="number">0.059912</span>,    <span class="number">0.094907</span>,    <span class="number">0.059912</span>,    <span class="number">0.015019</span>,</span><br><span class="line"><span class="number">0.003765</span>,    <span class="number">0.015019</span>,    <span class="number">0.023792</span>,    <span class="number">0.015019</span>,    <span class="number">0.003765</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">float2 offset[9] = </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">float2(-step_w, step_h),float2(0.0, step_h),float2(step_w, step_h),</span></span><br><span class="line"><span class="comment">float2(-step_w, 0.0),float2(0.0, 0.0),float2(step_w, 0.0), </span></span><br><span class="line"><span class="comment">float2(-step_w, -step_h),   float2(0.0, -step_h),float2(step_w, -step_h)</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">float kernel[9] = </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">0.094742,    0.118318,    0.094742, </span></span><br><span class="line"><span class="comment">0.118318,    0.147761,    0.118318, </span></span><br><span class="line"><span class="comment">0.094742,    0.118318,    0.094742</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">float4 sum = float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) </span><br><span class="line">&#123;</span><br><span class="line">float4 tmp = tex2D(_MainTex, i.uv + offset[j]);</span><br><span class="line">tmp.rgb = i.color.rgb;<span class="comment">// * tmp.a;</span></span><br><span class="line">sum += tmp * kernel[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum.a = <span class="built_in">pow</span>(sum.a, <span class="number">2</span>);</span><br><span class="line">albedo *= sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> albedo;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="五阶矩阵算子"><a href="#五阶矩阵算子" class="headerlink" title="五阶矩阵算子"></a>五阶矩阵算子</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> kernel[<span class="number">25</span>] = </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="number">0.003765</span>,    <span class="number">0.015019</span>,    <span class="number">0.023792</span>,    <span class="number">0.015019</span>,    <span class="number">0.003765</span>,</span><br><span class="line">    <span class="number">0.015019</span>,    <span class="number">0.059912</span>,    <span class="number">0.094907</span>,    <span class="number">0.059912</span>,    <span class="number">0.015019</span>,</span><br><span class="line">    <span class="number">0.023792</span>,    <span class="number">0.094907</span>,    <span class="number">0.150342</span>,    <span class="number">0.094907</span>,    <span class="number">0.023792</span>,</span><br><span class="line">    <span class="number">0.015019</span>,    <span class="number">0.059912</span>,    <span class="number">0.094907</span>,    <span class="number">0.059912</span>,    <span class="number">0.015019</span>,</span><br><span class="line">    <span class="number">0.003765</span>,    <span class="number">0.015019</span>,    <span class="number">0.023792</span>,    <span class="number">0.015019</span>,    <span class="number">0.003765</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h5 id="三阶矩阵算子"><a href="#三阶矩阵算子" class="headerlink" title="三阶矩阵算子"></a>三阶矩阵算子</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> kernel[<span class="number">9</span>] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0.094742</span>,    <span class="number">0.118318</span>,    <span class="number">0.094742</span>, </span><br><span class="line">    <span class="number">0.118318</span>,    <span class="number">0.147761</span>,    <span class="number">0.118318</span>, </span><br><span class="line">    <span class="number">0.094742</span>,    <span class="number">0.118318</span>,    <span class="number">0.094742</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
            <tag> Unity </tag>
            
            <tag> 高斯模糊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 一问一答</title>
      <link href="/C++%20%E4%B8%80%E9%97%AE%E4%B8%80%E7%AD%94.html"/>
      <url>/C++%20%E4%B8%80%E9%97%AE%E4%B8%80%E7%AD%94.html</url>
      
        <content type="html"><![CDATA[<h4 id="Some-questions-about-C"><a href="#Some-questions-about-C" class="headerlink" title="Some questions about C++"></a>Some questions about C++</h4><h4 id="Continue-Updating…"><a href="#Continue-Updating…" class="headerlink" title="Continue Updating…"></a>Continue Updating…</h4><br><h4 id="Difference-between-pointer-and-reference"><a href="#Difference-between-pointer-and-reference" class="headerlink" title="Difference between pointer and reference?"></a>Difference between pointer and reference?</h4><p>A:指针是变量的地址，引用是变量的别名，由指针实现。</p><p>More:简要说说其中7个不同之处：</p><p>1) 作为变量的不同：<br>        引用可以说是现有变量的别名。此变量的主要用途是作为参数，可作为引用传递（pass by reference）。函数内部对该引用参数所做的更改也将反映在函数外部的原始变量上。指针变量是存储地址的变量。与我们常用的int，double和char等普通变量不同，它存储变量的内存地址。</p><p>2) 声明的不同：<br>引用的声明方式是在变量前加一个 ‘&amp;’ 符号。<br>指针的声明方式是在变量前加一个 ‘*’ 符号。</p><p>3) 重新赋值：<br>引用不可以被重新赋值。<br>指针可以被重新赋值。</p><p>4) 内存地址：<br>引用变量和原始变量共享同一个地址。<br>指针拥有自己的地址，位于栈上。</p><p>5) Null 值：<br>引用不可以被赋值为 Null。<br>指针可以被赋值为 Null。</p><p>6) 间接性：<br>你可以使用指向指针的指针获得更高级别的间接性。而引用仅提供一种间接级别。</p><p>7) 算术操作：<br>可以对指针进行多种算术操作，但没有叫做引用算术的东西。</p><h5 id="Tips-什么时候使用引用，什么时候使用指针？"><a href="#Tips-什么时候使用引用，什么时候使用指针？" class="headerlink" title="Tips: 什么时候使用引用，什么时候使用指针？"></a>Tips: 什么时候使用引用，什么时候使用指针？</h5><p>引用：<br>    用于参数传递和返回值<br>指针：<br>    当需要进行指针运算，或者需要传入null指针时使用指针。比如操作数组。<br>    当实现一些如链表，树等数据结构时。</p><p><strong>Links</strong><br><a href="https://www.geeksforgeeks.org/pointers-vs-references-cpp/" target="_blank" rel="noopener">pointers vs references cpp</a><br><a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in" target="_blank" rel="noopener">difference between pointer variable and reference variable</a></p><br><h4 id="i-i-which-one-is-better"><a href="#i-i-which-one-is-better" class="headerlink" title="i++, ++i, which one is better?"></a>i++, ++i, which one is better?</h4><p>A:++i is better.</p><p>More:<br>对于简单类型（如int），二者没有性能区别，因为编译器会把 i++ 优化为 ++i。<br>然而，如果i是一个类，则这些 ++ 操作会调用类定义的 operator++ 函数。</p><p>以下为两个版本的 operator++ 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; Foo::<span class="keyword">operator</span>++()   <span class="comment">// called for ++i</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo Foo::<span class="keyword">operator</span>++(<span class="keyword">int</span> ignored_dummy_value)   <span class="comment">// called for i++</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;   <span class="comment">// variable "tmp" cannot be optimized away by the compiler</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于编译器不生成代码，而是仅仅调用operator ++函数，因此无法优化tmp变量及其关联的拷贝构造函数。如果拷贝构造函数代价高昂，那么这可能会对性能产生重大影响。</p><p><strong>Links</strong><br><a href="https://stackoverflow.com/questions/24901/is-there-a-performance-difference-between-i-and-i-in-c" target="_blank" rel="noopener">difference between i++ and ++i</a></p><br><h4 id="Why-use-virtual-destructor"><a href="#Why-use-virtual-destructor" class="headerlink" title="Why use virtual destructor?"></a>Why use virtual destructor?</h4><p>A:当您可能通过指向基类的指针删除派生类的实例时，虚拟析构函数很有用。<br>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// some virtual methods</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    ~Derived()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do some important cleanup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里没有声明Base的析构函数是虚析构函数。现在，让我们看一下以下代码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Derived();</span><br><span class="line"><span class="comment">// use b</span></span><br><span class="line"><span class="keyword">delete</span> b; <span class="comment">// Here's the problem!</span></span><br></pre></td></tr></table></figure><p>由于Base的析构函数不是虚拟的，并且b是指向派生对象的Base *，因此delete b具有未定义的行为：</p><blockquote><p>[在delete b中]，如果要删除的对象的静态类型(Base)与其动态类型(Derived)不同，则静态类型应为要删除的对象的动态类型的基类，并&gt; 且静态类型应具有虚拟析构函数,否则该行为是未定义的。</p></blockquote><p>在大多数实现中，对析构函数的调用将像任何非虚拟代码一样进行解析，这意味着将调用基类的析构函数，但不会调用派生类之一，从而导致资源泄漏。</p><p>综上所述，在需要对基类的析构函数进行多态操作时，始终使它们虚拟。</p><p>如果要防止通过基类指针删除实例，则可以使基类的析构函数为 protected 且是 non-virtual 的。这样，编译器将不允许您在基类指针上调用delete。</p><p><strong>Links</strong><br><a href="https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors?answertab=active#tab-top" target="_blank" rel="noopener">when to use virtual destructors</a></p><br><h4 id="What-is-the-signature-of-a-copy-constructor-assignment-operator"><a href="#What-is-the-signature-of-a-copy-constructor-assignment-operator" class="headerlink" title="What is the signature of a copy constructor / assignment operator?"></a>What is the signature of a copy constructor / assignment operator?</h4><p>A:<br>copy constructor:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo::Foo(<span class="keyword">const</span> Foo&amp; foo);</span><br></pre></td></tr></table></figure><p>assignment operator:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Foo&amp; foo);</span><br></pre></td></tr></table></figure><br><h4 id="How-to-specialize-a-class-template"><a href="#How-to-specialize-a-class-template" class="headerlink" title="How to specialize a class template?"></a>How to specialize a class template?</h4><p>A:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//original template class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 value1;</span><br><span class="line">    T2 value2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//original function template 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">max</span>(<span class="title">const</span> <span class="title">T</span> <span class="title">lhs</span>, <span class="title">const</span> <span class="title">T</span> <span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">return</span> lhs &gt; rhs ? lhs : rhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化：</span></span><br><span class="line"><span class="comment">//full template specialization 类模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;int, double&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">double</span> value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> lhs, <span class="keyword">const</span> <span class="keyword">int</span> rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> lhs &gt; rhs ? lhs : rhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化：</span></span><br><span class="line"><span class="comment">//函数模板不支持偏特化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;int, T2&gt;&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    T2 value2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h4 id="What-are-the-four-types-of-casts-in-C-Usage"><a href="#What-are-the-four-types-of-casts-in-C-Usage" class="headerlink" title="What are the four types of casts in C++? Usage?"></a>What are the four types of casts in C++? Usage?</h4><p>A: dynamic_cast, reinterpret_cast, static_cast and const_cast.</p><p>1) dynamic_cast<br>dynamic_cast can be used only with pointers and references to objects. Its purpose is to ensure that the result of the type conversion is a valid complete object of the requested class. It also performs the run-time check necessary to make the operation safe.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase &#123; &#125;;</span><br><span class="line"></span><br><span class="line">CBase b; CBase* pb;</span><br><span class="line">CDerived d; CDerived* pd;</span><br><span class="line"></span><br><span class="line">pb = <span class="keyword">dynamic_cast</span>&lt;CBase*&gt;(&amp;d);     <span class="comment">// ok: derived-to-base</span></span><br><span class="line">pd = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(&amp;b);  <span class="comment">// wrong: base-to-derived</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dynamic_cast</span></span><br><span class="line">include &lt;iostream&gt;</span><br><span class="line">include &lt;exception&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase &#123; <span class="keyword">int</span> a; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    CBase * pba = <span class="keyword">new</span> CDerived;</span><br><span class="line">    CBase * pbb = <span class="keyword">new</span> CBase;</span><br><span class="line">    CDerived * pd;</span><br><span class="line"></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(pba);</span><br><span class="line">    <span class="keyword">if</span> (pd==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Null pointer on first type-cast"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(pbb);</span><br><span class="line">    <span class="keyword">if</span> (pd==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Null pointer on second type-cast"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (exception&amp; e) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exception: "</span> &lt;&lt; e.what();&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>Null pointer on second type-cast</p></blockquote><p>pba和pbb都是 CBase* 类型的是指针，但是pba指向类型为 CDerived 类型的对象，pbb指向类型为 CBase 的对象，因此，当使用dynamic_cast执行它们各自的类型转换时，pba指向CDerived类的完整对象，而pbb指向CBase类的对象，该对象是CDerived类的不完整对象。<br>当所转换的指针指向的对象不是所需类型的完整对象时，dynamic_cast 返回空指针。</p><p>2) static_cast</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase &#123;&#125;;</span><br><span class="line">CBase * a = <span class="keyword">new</span> CBase;</span><br><span class="line">CDerived * b = <span class="keyword">static_cast</span>&lt;CDerived*&gt;(a);   <span class="comment">//could lead to runtime errors if dereferenced.</span></span><br></pre></td></tr></table></figure><p>static_cast 可用于将指向 CBase 类型的指针转化为 CDerived 类型，如果原指针指向的对象是 CBase 类型，那么该转化将得到一个指向不完整对象的指针，对该指针解引用可能引发运行时错误。<br>和 dynamic_cast 不同的是， static_cast 不会做运行时检查。</p><h5 id="some-difference-between-dynamic-cast-and-static-cast"><a href="#some-difference-between-dynamic-cast-and-static-cast" class="headerlink" title="some difference between dynamic_cast and static_cast"></a>some difference between dynamic_cast and static_cast</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static_cast_Operator_2.cpp</span></span><br><span class="line"><span class="comment">// compile with: /LD /GR</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B* pb)</span> </span>&#123;</span><br><span class="line">   D* pd1 = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb);</span><br><span class="line">   D* pd2 = <span class="keyword">static_cast</span>&lt;D*&gt;(pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况1：pb 指向类型为 D 的对象<br>If pb really points to an object of type D, then pd1 and pd2 will get the same value. They will also get the same value if pb == 0.</p><p>情况2：pb 指向类型为 B 的对象<br>If pb points to an object of type B and not to the complete D class, then dynamic_cast will know enough to return zero. However, static_cast relies on the programmer’s assertion that pb points to an object of type D and simply returns a pointer to that supposed D object.</p><p>3) reinterpret_cast<br>Allows any pointer to be converted into any other pointer type. Also allows any integral type to be converted into any pointer type and vice versa.</p><p>4) const_cast<br>Removes the const, volatile, and __unaligned attribute(s) from a class.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expre_const_cast_Operator.cpp</span></span><br><span class="line"><span class="comment">// compile with: /EHsc</span></span><br><span class="line">include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCTest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setNumber</span><span class="params">( <span class="keyword">int</span> )</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">()</span> <span class="keyword">const</span></span>;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCTest::setNumber( <span class="keyword">int</span> num ) &#123; number = num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CCTest::printNumber() <span class="keyword">const</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nBefore: "</span> &lt;&lt; number;</span><br><span class="line">   <span class="keyword">const_cast</span>&lt; CCTest * &gt;( <span class="keyword">this</span> )-&gt;number--;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nAfter: "</span> &lt;&lt; number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   CCTest X;</span><br><span class="line">   X.setNumber( <span class="number">8</span> );</span><br><span class="line">   X.printNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>On the line containing the const_cast, the data type of the this pointer is const CCTest *. The const_cast operator changes the data type of the this pointer to CCTest *, allowing the member number to be modified. The cast lasts only for the remainder of the statement in which it appears.</p><br><h4 id="Why-the-assignment-operator-usually-return-a-reference-const-reference"><a href="#Why-the-assignment-operator-usually-return-a-reference-const-reference" class="headerlink" title="Why the assignment operator usually return a reference/const reference?"></a>Why the assignment operator usually return a reference/const reference?</h4><p>A:Strictly speaking, the result of a copy assignment operator doesn’t need to return a reference.<br>Returning <strong>void</strong> will prevent users from <strong>‘assignment chaining’</strong> (a = b = c;), and will prevent using the result of an assignment in a test expression</p><p>Proformance reason:<br>If you return a reference, minimal work is done. The values from one object are copied to another object.<br>However, if you return by value for operator=, you will call a constructor AND destructor EACH time that the assignment operator is called!!</p><h5 id="more-about-copy-constructor-and-assignment-operator"><a href="#more-about-copy-constructor-and-assignment-operator" class="headerlink" title="more about copy constructor and assignment operator"></a>more about copy constructor and assignment operator</h5><p>Consider following class:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">Foo(<span class="keyword">int</span> _x) : x(_x)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor 2"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp; v)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~Foo()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstructor "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//first operator=</span></span><br><span class="line">Foo <span class="keyword">operator</span>=(Foo&amp; vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//second operator= (more effecient)</span></span><br><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp; foo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo Foo::<span class="keyword">operator</span>=(Foo&amp; foo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"operator = 1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Foo f;</span><br><span class="line">f.x = foo.x;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&amp; Foo::<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp; foo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"operator = 2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;x = foo.x;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When I write some code like this:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Foo <span class="title">v</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">Foo v2 = v;</span><br><span class="line">v2.x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result:</p><blockquote><p>constructor 2<br>copy constructor<br>deconstructor 2       <strong>deconstructor for v2</strong><br>deconstructor 1       <strong>deconstructor for v</strong></p></blockquote><p><strong>‘Foo v2 = v;’ is not assignment statement, but an initialization.</strong> <strong>So the copy constructor instead of the operator= is called.</strong> If you want the operator= to be called, change code to:<br>    Foo v2;<br>    v2 = v;</p><br><h4 id="shallow-copy-vs-deep-copy"><a href="#shallow-copy-vs-deep-copy" class="headerlink" title="shallow copy vs deep copy"></a>shallow copy vs deep copy</h4><p>Shallow copies duplicate as little as possible. A shallow copy of a collection is a copy of the collection structure, not the elements. With a shallow copy, two collections now share the individual elements.</p><p>Deep copies duplicate everything. A deep copy of a collection is two collections with all of the elements in the original collection duplicated.</p><br><h4 id="Inheritance-Access-Specifier"><a href="#Inheritance-Access-Specifier" class="headerlink" title="Inheritance Access Specifier"></a>Inheritance Access Specifier</h4><br> <p><img src="/img/postimg/class_inheritance_diagram.png" alt="inheritance"></p><br> Private:With private inheritance, public and protected member of the base class become private members of the derived class. That means the methods of the base class do not become the public interface of the derived object. However, they can be used inside the member functions of the derived class.<p>Public:<br>With public inheritance, the public methods of the base class become public methods of the derived class. In other words, the derived class inherits the base-class interface (the interface is still visible to outside and can use it). This is the is-a relationship. But with the private inheritance, the public methods of the base class become private methods of the derived class, even if they were protected or public in the base class. So, the derived class does not inherit the base-class interface.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Function Object</title>
      <link href="/C++%20Function%20Object.html"/>
      <url>/C++%20Function%20Object.html</url>
      
        <content type="html"><![CDATA[<h5 id="What-is-Function-Object"><a href="#What-is-Function-Object" class="headerlink" title="What is Function Object"></a>What is Function Object</h5><blockquote><p>A function object, or functor, is any type that implements operator(). This operator is referred to as the<br>call operator or sometimes the application operator. The C++ Standard Library uses function objects<br>primarily as sorting criteria for containers and in algorithms. </p></blockquote><br><h5 id="The-advantages-of-a-Function-Object-over-a-straight-function-call"><a href="#The-advantages-of-a-Function-Object-over-a-straight-function-call" class="headerlink" title="The advantages of a Function Object over a straight function call"></a>The advantages of a Function Object over a straight function call</h5><blockquote><p>Function objects provide two main advantages over a straight function call. The first is that a function object can contain state. The second is that a function object is a type and therefore can be used as a template parameter.</p></blockquote><br><p>函数对象相比普通函数/函数指针来说主要有两个优势：</p><ol><li>函数对象可以带有状态</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is a functor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_x</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    add_x(<span class="keyword">int</span> x) : x(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//the state</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now you can use it like this:</span></span><br><span class="line"><span class="function">add_x <span class="title">add42</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// create an instance of the functor class</span></span><br><span class="line"><span class="keyword">int</span> i = add42(<span class="number">8</span>); <span class="comment">// and "call" it</span></span><br><span class="line">assert(i == <span class="number">50</span>); <span class="comment">// and it added 42 to its argument</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in; <span class="comment">// assume this contains a bunch of values)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out(in.size());</span><br><span class="line"><span class="comment">// Pass a functor to std::transform, which calls the functor on every element </span></span><br><span class="line"><span class="comment">// in the input sequence, and stores the result to the output sequence</span></span><br><span class="line"><span class="built_in">std</span>::transform(in.begin(), in.end(), out.begin(), add_x(<span class="number">1</span>)); </span><br><span class="line">assert(out[i] == in[i] + <span class="number">1</span>); <span class="comment">// for all i</span></span><br></pre></td></tr></table></figure><p>倒数第二行，我们将函数对象作为参数传递给了另一个函数，你或许可以使用函数指针做到相同的事情，但是由于函数对象包含状态，因此可以被定制，你可以传入42，或者1，或者任何其他整数作为该函数对象的初始状态。</p><br><ol start="2"><li>函数对象是一种类型，因此可以作为泛型参数。</li></ol><br><ol start="3"><li>另一个相对函数指针的优点是，编译器知道 std::transform 应该调用的函数是 add_x::operator()， 因此编译器可以内联该函数从而提高效率。<br>但是如果换做一个函数指针，除非进行了一些复杂的全局优化，否则编译器不会立即知道它该调用哪一个函数，因此只能在运行时对该指针进行解引用，然后调用该函数。</li></ol><br><h5 id="The-usage-of-Function-Object"><a href="#The-usage-of-Function-Object" class="headerlink" title="The usage of Function Object"></a>The usage of Function Object</h5><ol><li>与容器搭配使用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Traits</span>=<span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Allocator</span>=<span class="title">allocator</span>&lt;Key&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">set</span></span></span><br></pre></td></tr></table></figure><p>上例中的less<key> 作为一个Function Object，可用于对 set 中的元素进行排序</key></p><blockquote><p>第二个模板参数是函数对象less。如果 less 的第一个参数小于第二个参数，则此函数对象返回true。由于某些容器会将其元素排序，因此&gt; 容器需要一种比较两个元素的方式。通过使用 Function Object 进行比较。您可以通过创建 Function Object 并在容器的模板列表中指&gt; 定它来为容器定义自己的排序标准。</p></blockquote><br><ol start="2"><li>和算法搭配使用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove_if</span>(</span></span><br><span class="line"><span class="class">    <span class="title">ForwardIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure><blockquote><p>remove_if的最后一个参数是返回布尔值（predicate断言）的函数对象。如果函数对象的结果为true，则将元素从容器中删除。您可以将<functional>标头中声明的任何函数对象用作参数pred，也可以创建自己的函数对象。</functional></p></blockquote><br><h5 id="A-simple-implemation-of-Function-Object"><a href="#A-simple-implemation-of-Function-Object" class="headerlink" title="A simple implemation of Function Object"></a>A simple implemation of Function Object</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="title">class</span> _<span class="title">Return</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Return return_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>, <span class="title">class</span> _<span class="title">Return</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Return return_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算数运算符</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">negate</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">return_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> argument_type&amp; _x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> -x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operatora</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; _x, <span class="keyword">const</span> second_argument_type&amp; _y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _x + _y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operatora</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; _x, <span class="keyword">const</span> second_argument_type&amp; _y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _x - _y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">multiply</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operatora</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; _x, <span class="keyword">const</span> second_argument_type&amp; _y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _x * _y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">divide</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operatora</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; _x, <span class="keyword">const</span> second_argument_type&amp; _y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _x / _y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">module</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operatora</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; _x, <span class="keyword">const</span> second_argument_type&amp; _y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _x % _y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关系运算符</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; x, <span class="keyword">const</span> second_argument_type&amp; y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; x, <span class="keyword">const</span> second_argument_type&amp; y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; x, <span class="keyword">const</span> second_argument_type&amp; y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑运算符</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">return_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; _x, <span class="keyword">const</span> second_argument_type&amp; _y)</span> </span>&#123; <span class="keyword">return</span> _x &amp;&amp; _y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_or</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">return_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; _x, <span class="keyword">const</span> second_argument_type&amp; _y)</span> </span>&#123; <span class="keyword">return</span> _x || _y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_not</span> :</span> <span class="keyword">public</span> unary_function&lt;T, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">return_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> argument_type&amp; _x)</span> </span>&#123; <span class="keyword">return</span> !_x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><p><strong>Links:</strong></p><p><a href="https://docs.microsoft.com/en-us/cpp/standard-library/function-objects-in-the-stl?view=vs-2019" target="_blank" rel="noopener">Function Objects in the C++ Standard Library</a></p><p><a href="https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses" target="_blank" rel="noopener">What are C++ functors and their uses?</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> functor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ pre-increment &amp; post-increment</title>
      <link href="/C++%20pre-increment%20&amp;%20post-increment.html"/>
      <url>/C++%20pre-increment%20&amp;%20post-increment.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>This article is about pre-increment and post-increment operator in C++.<br>Also you may thought of pre-decrement and post-decrement operator in C++.<br>But in this article i will mainly talk about the ‘++’ because the ‘–’ operator has the same usage as ‘++’.</p></blockquote><h4 id="What-exactly-the-pre-increment-operator-and-post-increment-operator-are"><a href="#What-exactly-the-pre-increment-operator-and-post-increment-operator-are" class="headerlink" title="What exactly the pre-increment operator and post-increment operator are"></a>What exactly the pre-increment operator and post-increment operator are</h4><p>Given an object named x(that supports the ++ operator, of course).</p><p>pre-increment: ++x<br>post-increment: x++</p><h4 id="Some-code-that-confused-me-a-lot"><a href="#Some-code-that-confused-me-a-lot" class="headerlink" title="Some code that confused me a lot"></a>Some code that confused me a lot</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pre-increment</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">operator</span>++();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//post-increment</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">operator</span>++(<span class="title">int</span>);</span></span><br></pre></td></tr></table></figure><p>What is the difference between the above two declarations ?<br>Obviously, the argument and the return value is different.</p><p>The ‘int’ parameter in post-increment is used only to differ from the pre-increment declaration.<br>The more important part is the return type difference.</p><p>Here are the implementation of the two functions:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pre-increment</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">T</span>:</span>:<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    data += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//post-increment</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">T</span>:</span>:<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The post-increment returns a <strong>copy</strong> of the tmp object, meaning that there should be a <strong>copy constructor</strong> called,and this is <strong>inefficient</strong> comparing to the pre-increment.</p><p>But in some other cases the behaviour of returning a copy of the object is very useful.</p><p>Not use post-increment:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; my_list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = my_list.begin();</span><br><span class="line">++iter;</span><br><span class="line">my_list.erase(iter);</span><br><span class="line"><span class="comment">//error !!!</span></span><br><span class="line">my_list.insert(iter, <span class="number">33</span>);</span><br></pre></td></tr></table></figure><p>Use post-increment:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; my_list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = my_list.begin();</span><br><span class="line">++iter;</span><br><span class="line">my_list.erase(iter++);</span><br><span class="line"><span class="comment">//ok !!!</span></span><br><span class="line">my_list.insert(iter, <span class="number">33</span>);</span><br></pre></td></tr></table></figure><p>OR</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; my_list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = my_list.begin();</span><br><span class="line">++iter;</span><br><span class="line">iter = my_list.erase(iter);</span><br><span class="line"><span class="comment">//also ok.</span></span><br><span class="line">my_list.insert(iter, <span class="number">33</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> ++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Virtual Function</title>
      <link href="/C++%20Virtual%20Function.html"/>
      <url>/C++%20Virtual%20Function.html</url>
      
        <content type="html"><![CDATA[<h4 id="什么是虚函数"><a href="#什么是虚函数" class="headerlink" title="什么是虚函数"></a>什么是虚函数</h4><blockquote><p>A virtual function is a member function that you expect to be redefined in derived classes.When you refer to &gt; a derived class object using a pointer or a reference to the base class, you can call a virtual function for &gt; that object and execute the derived class’s version of the function.</p></blockquote><br> <h5 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h5><ol><li>虚函数可确保为对象调用正确的函数，而不管用于函数调用的引用（或指针）的类型是什么类型。</li><li>它们主要用于实现运行时多态。</li><li>函数在基类中使用 ##virtual## 关键字声明。</li><li>函数调用的解析在运行时完成。</li></ol><br> <h4 id="虚函数的规则"><a href="#虚函数的规则" class="headerlink" title="虚函数的规则"></a>虚函数的规则</h4><ol><li>虚函数不能是静态的，也不能作为另一个类的友元函数。</li><li>应该使用基类类型的指针或引用来访问虚拟函数，以实现运行时多态。</li><li>虚拟函数的函数原型在基类和派生类中都应相同。</li><li>它们始终在基类中定义，而在派生类中被重载。并不强制派生类重载（或重定义虚拟函数），如果子类中没有重载，将使用基类中的版本。</li><li>一个类可能具有虚拟析构函数，但不能具有虚拟构造函数。</li></ol><br> <h4 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to illustrate </span></span><br><span class="line"><span class="comment">// concept of Virtual Functions </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"print base class"</span> &lt;&lt;<span class="built_in">endl</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"show base class"</span> &lt;&lt;<span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span><span class="keyword">public</span> base </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"print derived class"</span> &lt;&lt;<span class="built_in">endl</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"show derived class"</span> &lt;&lt;<span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">base *bptr; </span><br><span class="line">derived d; </span><br><span class="line">bptr = &amp;d; </span><br><span class="line"></span><br><span class="line"><span class="comment">//virtual function, binded at runtime </span></span><br><span class="line">bptr-&gt;print(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-virtual function, binded at compile time </span></span><br><span class="line">bptr-&gt;show(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <p>上例输出为：</p><blockquote><p>print derived class<br>show base class</p></blockquote><br> <p>运行时多态只能通过基类类型的指针（或引用）来实现。同样，基类指针可以指向基类的对象以及派生类的对象。在上面的代码中，基类指针 “bptr” 包含派生类的对象 “d” 的地址。后期绑定（运行时）是根据指针的内容（即指针指向的位置）完成的，而早期绑定（编译时）是根据指针的类型完成的，因为print（）函数是用 virtual 关键字声明的，因此将在运行时绑定（输出是 “print derived class” ，因为指针指向派生类的对象），而show（）是非虚拟的，因此它将在编译时绑定（输出是 “show base class” ，因为指针是基类的类型）。</p><br><h4 id="虚函数机制（VTABLE和VPTR的概念）"><a href="#虚函数机制（VTABLE和VPTR的概念）" class="headerlink" title="虚函数机制（VTABLE和VPTR的概念）"></a>虚函数机制（VTABLE和VPTR的概念）</h4><p>如果一个类包含一个虚函数，那么编译器本身会做两件事：</p><ol><li>如果创建了该类的对象，则将虚拟指针（VPTR）作为该类的数据成员插入，以指向该类的VTABLE。对于创建的每个新对象，将插入一个新的虚拟指针作为该类的数据成员。</li><li>不管是否创建对象，都会产生一个称为VTABLE的包含函数指针的静态数组，其中每个单元格包含该类中包含的每个虚函数的地址。</li></ol><br> <p>考虑下面的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to illustrate </span></span><br><span class="line"><span class="comment">// working of Virtual Functions </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base-1\n"</span>; &#125; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base-2\n"</span>; &#125; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base-3\n"</span>; &#125; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_4</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base-4\n"</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"derived-1\n"</span>; &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"derived-2\n"</span>; &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"derived-4\n"</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">base *p; </span><br><span class="line">derived obj1; </span><br><span class="line">p = &amp;obj1; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Early binding because fun1() is non-virtual </span></span><br><span class="line"><span class="comment">// in base </span></span><br><span class="line">p-&gt;fun_1(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Late binding (RTP) </span></span><br><span class="line">p-&gt;fun_2(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Late binding (RTP) </span></span><br><span class="line">p-&gt;fun_3(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Late binding (RTP) </span></span><br><span class="line">p-&gt;fun_4(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Early binding but this function call is </span></span><br><span class="line"><span class="comment">// illegal(produces error) becasue pointer </span></span><br><span class="line"><span class="comment">// is of base type and function is of </span></span><br><span class="line"><span class="comment">// derived class </span></span><br><span class="line"><span class="comment">//p-&gt;fun_4(5); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <p>说明：最初，我们创建一个基类类型的指针，并使用派生类对象的地址对其进行初始化。当我们创建派生类的对象时，编译器会创建一个指针，这个指针属于派生类的数据成员，包含该派生类的VTABLE地址。<br>上例中使用了类似后期绑定和早期绑定的概念。对于fun_1（）函数调用，该函数的基类版本被调用，fun_2（）在派生类中被覆盖，因此派生类版本被调用，fun_3（）在派生类中不被覆盖，它是虚函数，因此该基类版本被调用，同样，fun_4（）不会被覆盖，因此将调用基类版本。</p><br> <h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>理解 Early-Binding 和 Late-Binding.</li><li>上例中 func1 在基类中没有虚函数版本，因此会使用 Early-Binding，使用哪个版本的 func1 完全取决于调用 func1 时其调用对象的类型。</li><li>c++11 引入的 override 关键字可以加在子类重载函数的签名之后，用以指明该函数是一个重载函数，如果该该函数实际上并不是一个重载函数（如签名与基类中虚函数的签名不一致），则将引发编译错误。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Smart Pointer</title>
      <link href="/C++%20Smart%20Pointer.html"/>
      <url>/C++%20Smart%20Pointer.html</url>
      
        <content type="html"><![CDATA[<h4 id="智能指针的使用"><a href="#智能指针的使用" class="headerlink" title="智能指针的使用"></a>智能指针的使用</h4><p>智能指针在<memory>头文件的std名称空间中定义。它们对于RAII即“资源获取是初始化”编程习惯至关重要。这种习惯用法的主要目标是确保在初始化对象的同时进行资源获取，以便在一行代码中创建并准备好对象的所有资源。实际上，RAII的主要原理是将任何已分配堆资源的所有权（例如，动态分配的内存或系统对象句柄）赋予堆栈分配的对象，该对象的析构函数包含删除或释放资源的代码，以及任何相关的清理代码。</memory></p><p>多数情况下，当你初始化一个指向实际资源的原始指针（raw pointer）或者资源句柄时，请立即把这个指针传递给智能指针。</p><p>在现代C++中，原始指针只用在小的代码片段中，如有限的范围（limited scope），循环，或者帮助函数等一些性能敏感且不会产生所有权混淆的地方。</p><p>下面的例子对原始指针和智能指针的声明作了比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Using a raw pointer -- not recommended.</span></span><br><span class="line">    Song* pSong = <span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pSong...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't forget to delete!</span></span><br><span class="line">    <span class="keyword">delete</span> pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseSmartPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Declare a smart pointer on stack and pass it the raw pointer.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Song&gt; song2(<span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use song2...</span></span><br><span class="line">    wstring s = song2-&gt;duration_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// song2 is deleted automatically here.</span></span><br></pre></td></tr></table></figure><br> <p>如示例中所示，智能指针是您在堆栈上声明的类模板，并使用指向堆分配对象的原始指针进行初始化。智能指针初始化后，它拥有原始指针。这意味着智能指针负责删除/释放原始指针指定的内存。智能指针析构函数包含对delete的调用，并且由于智能指针是在堆栈上声明的，因此即使智能异常超出堆栈范围，也会在智能指针超出范围时调用其析构函数。</p><p>使用熟悉的指针运算符-&gt;和*访问封装的指针，智能指针类会重载它们以返回封装的原始指针。</p><p>C ++智能指针习惯用法类似于C＃等语言中的对象创建：创建对象，然后让系统负责在正确的时间删除它。不同之处在于，没有单独的垃圾收集器在后台运行。内存通过标准C ++范围规则进行管理，因此运行时环境更快，更高效。</p><blockquote><p><strong>重要</strong><br>始终在单独的代码行上创建智能指针，而不要在参数列表中创建智能指针，以免由于某些参数列表分配规则而导致细微的资源泄漏。</p></blockquote><br> <p>下面的示例演示如何使用C ++标准库中的unique_ptr智能指针类型来封装指向大对象的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessLargeObject</span><span class="params">(<span class="keyword">const</span> LargeObject&amp; lo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; pLarge(<span class="keyword">new</span> LargeObject());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass a reference to a method.</span></span><br><span class="line">    ProcessLargeObject(*pLarge);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//pLarge is deleted automatically when function block goes out of scope.</span></span><br></pre></td></tr></table></figure><br> <p>该示例演示了以下使用智能指针的基本步骤。</p><ol><li>将智能指针声明为自动（本地）变量。（请勿在智能指针本身上使用new或malloc表达式。）</li><li>在type参数中，指定封装指针的指向类型。（上例中为 LargeObject）</li><li>将指向新创建对象的原始指针传递给智能指针构造函数中。（某些 utility 函数或智能指针构造函数会为您执行此操作。）</li><li>使用重载的 -&gt; 和 * 操作符访问对象</li><li>让智能指针删除该对象</li></ol><p>智能指针被设计为在内存和性能上都尽可能高效。例如，unique_ptr中唯一的数据成员是封装的指针。这意味着unique_ptr与该指针的大小完全相同，为四个字节或八个字节。通过使用智能指针重载*和-&gt;运算符来访问封装的指针，并不比直接访问原始指针慢多少。</p><p>智能指针具有自己的成员函数，可以使用“点”表示法进行访问。例如，某些C++标准库智能指针具有重置成员函数，该函数释放指针的所有权。当您要在智能指针超出作用域之前释放智能指针拥有的内存时，此功能很有用，如以下示例所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; pLarge(<span class="keyword">new</span> LargeObject());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the memory before we exit function block.</span></span><br><span class="line">    pLarge.reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some other work...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针通常提供直接访问其原始指针的方法。为此，C++标准库智能指针具有get成员函数，而CComPtr具有公共p类成员。通过提供对基础指针的直接访问，您可以使用智能指针来管理自己的代码中的内存，并且仍将原始指针传递给不支持智能指针的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; pLarge(<span class="keyword">new</span> LargeObject());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass raw pointer to a legacy API</span></span><br><span class="line">    LegacyLargeObjectFunction(pLarge.get());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <h4 id="智能指针的种类"><a href="#智能指针的种类" class="headerlink" title="智能指针的种类"></a>智能指针的种类</h4><p>以下部分总结了Windows编程环境中可用的各种智能指针，并描述了何时使用它们。</p><p><strong>C++标准库智能指针</strong></p><p>使用这些智能指针作为封装指向 plain old C++对象（POCO）的指针的首选。</p><ol><li><p>unique_ptr<br>只允许基础指针拥有一个所有者。除非确定您需要 shared_ptr，否则将其用作 POCO 的默认选项。可以移动到新所有者，但不能复制或共享。它用于替换不推荐使用的 auto_ptr。与 boost::scoped_ptr 比较，unique_ptr 小而有效；它的大小只相当于一个指针的大小，它支持右值引用，以便快速插入和检索 C++ 标准库集合。它包含于头文件 memory。</p></li><li><p>shared_ptr<br>引用计数的智能指针。当您要将一个原始指针分配给多个所有者时，例如，当您从容器中返回一个指针的副本但又想保留容器中的原始指针时，请使用此函数。在所有 shared_ptr 所有者都超出范围或放弃所有权之前，不会删除原始指针。它的大小是两个指针大小；一个用于指向对象，另一个用于包含引用计数的共享控制块。它包含于头文件 memory。</p></li><li><p>weak_ptr<br>与 shared_ptr 结合使用的特殊情况下的智能指针。weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。当您要观察物体但不要求其保持活动状态时使用。在某些情况下，需要此属性来断开 shared_ptr 实例之间的循环引用。它包含于头文件 memory。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码赏析之smart pointer</title>
      <link href="/STL%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%B9%8Bsmart%20pointer.html"/>
      <url>/STL%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%B9%8Bsmart%20pointer.html</url>
      
        <content type="html"><![CDATA[<h4 id="Smart-Pointer"><a href="#Smart-Pointer" class="headerlink" title="Smart Pointer"></a>Smart Pointer</h4><h5 id="引用计数相关-–-Ref-h"><a href="#引用计数相关-–-Ref-h" class="headerlink" title="引用计数相关 – Ref.h"></a>引用计数相关 – Ref.h</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Impl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ref_t 中 _deleter的默认值（默认析构函数）</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> _<span class="title">default_delete</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span> </span>&#123; <span class="keyword">if</span> (ptr) <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">ref_t</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//std::function&lt;void(T*)&gt; 其中void(T*)中的void表示返回值，T*表示函数参数</span></span><br><span class="line">        <span class="keyword">using</span> deleter_type = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T*)&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类型为size_t的原子类型，确保线程安全</span></span><br><span class="line">        <span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; _ncount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原始指针</span></span><br><span class="line">        T* _data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">        deleter_type _deleter;</span><br><span class="line"></span><br><span class="line">        explicit ref_t(T* p = nullptr, deleter_type pfunc = deleter_type(_default_delete&lt;T&gt;())) :_ncount(0), _data(p), _deleter(pfunc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_data)</span><br><span class="line">                _ncount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ref_t</span>(<span class="keyword">const</span> <span class="keyword">ref_t</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="keyword">ref_t</span>&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">ref_t</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果引用计数为0，释放对象</span></span><br><span class="line">        ~<span class="keyword">ref_t</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            --ncount;</span><br><span class="line">            <span class="keyword">if</span> (_ncount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _deleter(_data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原子操作获取原子对象的值</span></span><br><span class="line">        <span class="keyword">size_t</span> count()<span class="keyword">const</span> &#123; <span class="keyword">return</span> _ncount.load(); &#125;</span><br><span class="line">        <span class="function">T* <span class="title">get_data</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ref_t</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line">        &#123;</span><br><span class="line">            ++_ncount;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ref_t</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = *<span class="keyword">this</span>;</span><br><span class="line">            ++* <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ref_t</span>&amp; <span class="keyword">operator</span>--()</span><br><span class="line">        &#123;</span><br><span class="line">            --_ncount;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ref_t</span> <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = *<span class="keyword">this</span>;</span><br><span class="line">            --* <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较原始指针</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">ref_t</span>&lt;T&gt;&amp; <span class="title">lhs</span>, <span class="title">const</span> <span class="title">ref_t</span>&lt;T&gt;&amp; <span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">return</span> lhs.get_data() == rhs.get_data();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">operator</span>!=(<span class="title">const</span> <span class="title">ref_t</span>&lt;T&gt;&amp; <span class="title">lhs</span>, <span class="title">const</span> <span class="title">ref_t</span>&lt;T&gt;&amp; <span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span> </span>&#123; <span class="keyword">if</span> (ptr) <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">default_delete</span>&lt;T[]&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span> </span>&#123; <span class="keyword">if</span> (ptr) &#123; <span class="keyword">delete</span>[] ptr; &#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">D</span> = <span class="title">default_delete</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unique_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T element_type;</span><br><span class="line">    <span class="keyword">typedef</span> D deleter_type;</span><br><span class="line">    <span class="keyword">typedef</span> element_type* pointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit unique_ptr(T* data = nullptr) :_data(data) &#123;&#125;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(T* data, deleter_type del) :_data(data), deleter(del) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过右值引用作为构造函数的参数</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; up) :_data(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MySTL::swap(_data, up.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过右值引用赋值</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&amp;&amp; up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;up != <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            clean();</span><br><span class="line">            MySTL::swap(*<span class="keyword">this</span>, up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁用拷贝构造</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//禁用赋值</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() &#123; clean(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> pointer <span class="title">get</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">    <span class="function">pointer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">    <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> deleter; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> deleter; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可实现该类型对象到bool类型的隐式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get() != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放unique_ptr指向的对象</span></span><br><span class="line">    <span class="function">pointer <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T* p = <span class="literal">nullptr</span>;</span><br><span class="line">        MySTL::swap(p, _data);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置unique_ptr指向的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer p = pointer())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clean();</span><br><span class="line">        _data = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">unique_ptr</span>&amp; up)</span> </span>&#123; MySTL::swap(_data, up._data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解引用获取指向的对象</span></span><br><span class="line">    <span class="keyword">const</span> element_type&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span> &#123; <span class="keyword">return</span> *_data; &#125;</span><br><span class="line">    <span class="comment">//获取对象的原始指针</span></span><br><span class="line">    <span class="keyword">const</span> pointer <span class="keyword">operator</span>-&gt;()<span class="keyword">const</span> &#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解引用获取指向的对象</span></span><br><span class="line">    element_type&amp; <span class="keyword">operator</span>*()&#123; <span class="keyword">return</span> *_data; &#125;</span><br><span class="line">    <span class="comment">//获取对象的原始指针</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;()&#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        deleter(_data);</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pointer _data;</span><br><span class="line">    deleter_type deleter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">unique_ptr</span>&lt;T, D&gt;&amp; <span class="title">x</span>, <span class="title">unique_ptr</span>&lt;T, D&gt;&amp; <span class="title">y</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    x.swap(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个unique_ptr比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">D1</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">class</span> <span class="title">D2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span> == (<span class="title">const</span> <span class="title">unique_ptr</span>&lt;T1, D1&gt;&amp; <span class="title">lhs</span>, <span class="title">const</span> <span class="title">unique_ptr</span>&lt;T2, D2&gt;&amp; <span class="title">rhs</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> lhs.get() == rhs.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针与unique_ptr比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span> == (<span class="title">const</span> <span class="title">unique_ptr</span>&lt;T, D&gt;&amp; <span class="title">up</span>, <span class="title">nullptr_t</span> <span class="title">p</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> up.get() == p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针与unique_ptr比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span> == (<span class="title">nullptr_t</span> <span class="title">p</span>, <span class="title">const</span> <span class="title">unique_ptr</span>&lt;T, D&gt;&amp; <span class="title">up</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> up.get() == p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个unique_ptr比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">D1</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">class</span> <span class="title">D2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span> != (<span class="title">const</span> <span class="title">unique_ptr</span>&lt;T1, D1&gt;&amp; <span class="title">lhs</span>, <span class="title">const</span> <span class="title">unique_ptr</span>&lt;T2, D2&gt;&amp; <span class="title">rhs</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针与unique_ptr比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span> != (<span class="title">const</span> <span class="title">unique_ptr</span>&lt;T, D&gt;&amp; <span class="title">up</span>, <span class="title">nullptr_t</span> <span class="title">p</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> up.get() != p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针与unique_ptr比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span> != (<span class="title">nullptr_t</span> <span class="title">p</span>, <span class="title">const</span> <span class="title">unique_ptr</span>&lt;T, D&gt;&amp; <span class="title">up</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> up.get() != p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span>(<span class="title">Args</span>&amp;&amp; ... <span class="title">args</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding C++ keywords</title>
      <link href="/Understanding%20C++%20keywords.html"/>
      <url>/Understanding%20C++%20keywords.html</url>
      
        <content type="html"><![CDATA[<h3 id="C-关键字详解"><a href="#C-关键字详解" class="headerlink" title="C++关键字详解"></a>C++关键字详解</h3><br> <h4 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h4><h5 id="typename-不太常见的一种用法"><a href="#typename-不太常见的一种用法" class="headerlink" title="typename 不太常见的一种用法"></a>typename 不太常见的一种用法</h5><p>C++模板的常见写法是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; ...</span></span><br></pre></td></tr></table></figure><p>当然，你可以使用 typename 替代 class 表达相同的意思：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; ...</span><br></pre></td></tr></table></figure><p>以上两例中，typename 和 class 都可以用来表明模板参数是一个类型。</p><p>然而在实际使用中，建议在上例的情况下使用 class 而不是 typename 关键字，而将 typename 用于一些更需要它的情景中（即 typename 的另一种用法），以避免混淆。</p><br> <h5 id="更加常见的-typename-用法"><a href="#更加常见的-typename-用法" class="headerlink" title="更加常见的 typename 用法"></a>更加常见的 typename 用法</h5><p>首先弄明白两组概念：</p><h6 id="qualified-unqualified-name："><a href="#qualified-unqualified-name：" class="headerlink" title="qualified/unqualified  name："></a>qualified/unqualified  name：</h6><blockquote><p><strong>Short Explain:</strong> A qualified name is one that has some sort of indication of where it belongs, e.g. a class specification, namespace specification, etc. An unqualified name is one that isn’t qualified. </p><p><strong>Example:</strong></p><p> Given: </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>A</code> is an <em>unqualified-id</em>.</li><li><code>::A</code> is a <em>qualified-id</em> but has no <em>nested-name-specifier</em>.</li><li><code>A::B</code> is a <em>qualified-id</em> and <code>A::</code> is a <em>nested-name-specifier</em>.</li><li><code>::A::B</code> is a <em>qualified-id</em> and <code>A::</code> is a <em>nested-name-specifier</em>.</li><li><code>A::B::F</code> is a <em>qualified-id</em> and both <code>B::</code> and <code>A::B::</code> are <em>nested-name-specifiers</em>.</li><li><code>::A::B::F</code> is a <em>qualified-id</em> and both <code>B::</code> and <code>A::B::</code> are <em>nested-name-specifiers</em>.</li></ul></blockquote><br> <h6 id="dependent-non-dependent-name"><a href="#dependent-non-dependent-name" class="headerlink" title="dependent/non-dependent name"></a>dependent/non-dependent name</h6><blockquote><p>Given:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vitr;</span><br><span class="line">   </span><br><span class="line">   T t;</span><br><span class="line">   <span class="built_in">vector</span>&lt;T&gt; vt;</span><br><span class="line">   <span class="built_in">vector</span>&lt;T&gt;::iterator viter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>The types of the first three declarations are known at the time of the template declaration. However, the types of the second set of three declarations are <em>not</em> known until the point of instantiation, because they depend on the template parameter <code>T</code>.</p><p>The names <code>T</code>, <code>vector</code>, and <code>vector::iterator</code> are called <strong>dependent names</strong>, and the types they name are dependent types. The names used in the first three declarations are called <strong>non-dependent names</strong>, at the types are non-dependent types.</p></blockquote><br> <br> <p>Known about the above two pairs of concepts, We can then easily explain the main usage of the keyword ‘typename’.</p><p>考虑以下的情况：</p><p>下面是一个普通的模板函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>() &#123;</span></span><br><span class="line">   T::iterator * iter;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序员可能会定义以下的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainsAType</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span> ... &#125;:</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后使用类型 ContainsAType 实例化 foo 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&lt;ContainsAType&gt;();</span><br></pre></td></tr></table></figure><p>这时，foo 函数中的 iter 表示一个指向类 iterator 的指针，这样做完全没有问题。</p><br> <p>然而事实并不总是如想象中那样美好，如果有别人定义了以下变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainsAType</span> &#123;</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么上面的函数调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&lt;ContainsAType&gt;();</span><br></pre></td></tr></table></figure><p>就会变成 ContainsAType 类的 iterator 对象和 iter 相乘。</p><br> <p><strong>为避免这种情况的出现，需要注意：</strong>在定义一个  <strong>qualified dependent type</strong> 的时候，需要在其前面加上 <strong>typename</strong> 关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>() &#123;</span></span><br><span class="line">   <span class="keyword">typename</span> T::iterator * iter;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <br> <p><strong>Links:</strong></p><p><a href="http://pages.cs.wisc.edu/~driscoll/typename.html" target="_blank" rel="noopener">A Description of the C++ ‘typename’ keyword</a></p><p><a href="https://stackoverflow.com/questions/7257563/what-are-qualified-id-name-and-unqualified-id-name" target="_blank" rel="noopener">What are qualified-id/name and unqualified-id/name?</a></p><p><a href="https://stackoverflow.com/questions/1600936/officially-what-is-typename-for" target="_blank" rel="noopener">Officially, what is typename for?</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> keyword </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唐代诗人的非自然死亡</title>
      <link href="/%E5%94%90%E4%BB%A3%E8%AF%97%E4%BA%BA%E7%9A%84%E9%9D%9E%E8%87%AA%E7%84%B6%E6%AD%BB%E4%BA%A1.html"/>
      <url>/%E5%94%90%E4%BB%A3%E8%AF%97%E4%BA%BA%E7%9A%84%E9%9D%9E%E8%87%AA%E7%84%B6%E6%AD%BB%E4%BA%A1.html</url>
      
        <content type="html"><![CDATA[<br> <p><img src="/img/postimg/poem.jpg" alt="poem"></p><br> <h4 id="唐代诗人的非自然死亡"><a href="#唐代诗人的非自然死亡" class="headerlink" title="唐代诗人的非自然死亡"></a>唐代诗人的非自然死亡</h4><br> <p><strong><em>“落霞与孤鹜齐飞，秋水共长天一色。”</em></strong></p><p><strong>王勃：</strong>失足落水，惊悸而死。</p><br> <p><strong><em>“得成比目何辞死，愿作鸳鸯不羡仙。”</em></strong></p><p><strong>卢照邻：</strong>因麻疹疾病，不堪重负，投水自尽。</p><br> <p><strong><em>“鹅，鹅，鹅，曲项向天歌。”</em></strong></p><p><strong>骆宾王：</strong>造反失败，下落不明。</p><br> <p><strong><em>“念天地之悠悠，独怆然而涕下。”</em></strong></p><p><strong>陈子昂：</strong>遭陷害，冤死狱中。</p><br> <p><strong><em>“秦时明月汉时关，万里长征人未还。”</em></strong></p><p><strong>王昌龄：</strong>旅游时当地官员嫉妒其才能，将他杀害。</p><br> <p><strong><em>“春眠不觉晓，处处闻啼鸟。”</em></strong></p><p><strong>孟浩然：</strong>生病后吃了不该吃的东西(鱼），卒。</p><br> <p><strong><em>“漆灰骨末丹水砂，凄凄古血生铜花。”</em></strong></p><p><strong>李贺：</strong>仕进无路，体弱多病，27岁病逝。</p><br> <p><strong><em>“年年岁岁花相似，岁岁年年人不同。”</em></strong></p><p><strong>刘希夷：</strong>拒绝将此诗著作权转让给舅舅宋之问，被宋之问杀害。</p>]]></content>
      
      
      <categories>
          
          <category> 历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史 </tag>
            
            <tag> 唐诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码赏析之constructor</title>
      <link href="/STL%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%B9%8Bconstructor.html"/>
      <url>/STL%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%B9%8Bconstructor.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>STL中包含五个用于内存处理的全局函数，constructor.h包含其中的两个：destroy, construct。</p></blockquote><p>constructor.h源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">include &lt;<span class="keyword">new</span>&gt;</span><br><span class="line"></span><br><span class="line">include <span class="string">"TypeTraits.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySTL &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> construct(T1* ptr1, <span class="keyword">const</span> T2&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">new</span>(ptr1) T1(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">ptr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ptr-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, _<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, _<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">&#123;</span><br><span class="line">destroy(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _type_traits&lt;ForwardIterator&gt;::is_POD_type is_POD_type;</span><br><span class="line">_destroy(first, last, is_POD_type());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor.h 中包含一个 construct 函数和两个版本的 destroy 函数。</p><p>construct 函数的实现比较简单，使用 placement new 通过 T1的拷贝构造函数在已分配的内存上构造一个对象。</p><p>关于 placement new :</p><blockquote><p>Placement new is a variation new operator in C++. Normal new operator does two things :<br>        (1) Allocates memory<br>        (2) Constructs an object in allocated memory.</p><p>Placement new allows us to separate above two things. In placement new, we can pass a preallocated memory and construct an object in the passed memory.</p></blockquote><p>destroy 函数包含两个版本，直接析构版本和迭代器版本。</p><ol><li>第一个版本直接调用传入指针所指对象的析构函数。</li><li>第二个版本先判断传入类型是否是 pod type，如果是，则不必调用析构函数，如果不是，则依次调用析构函数。</li></ol><p>什么是 POD 类型：<a href="https://stackoverflow.com/questions/146452/what-are-pod-types-in-c" target="_blank" rel="noopener">POD</a></p><blockquote><h3 id="Very-informally"><a href="#Very-informally" class="headerlink" title="Very informally:"></a>Very informally:</h3><p>A POD is a type (including classes) where the C++ compiler guarantees that there will be no “magic” going on in the structure: for example hidden pointers to vtables, offsets that get applied to the address when it is cast to other types (at least if the target’s POD too), constructors, or destructors. Roughly speaking, a type is a POD when the only things in it are built-in types and combinations of them. The result is something that “acts like” a C type.</p><h3 id="Less-informally"><a href="#Less-informally" class="headerlink" title="Less informally:"></a>Less informally:</h3><ul><li><code>int</code>, <code>char</code>, <code>wchar_t</code>, <code>bool</code>, <code>float</code>, <code>double</code> are PODs, as are <code>long/short</code> and <code>signed/unsigned</code> versions of them.</li><li>pointers (including pointer-to-function and pointer-to-member) are PODs,</li><li><code>enums</code> are PODs</li><li>a <code>const</code> or <code>volatile</code> POD is a POD.</li><li>a <code>class</code>, <code>struct</code> or <code>union</code> of PODs is a POD provided that all non-static data members are <code>public</code>, and it has no base class and no constructors, destructors, or virtual methods. Static members don’t stop something being a POD under this rule. This rule has changed in C++11 and certain private members are allowed: <a href="https://stackoverflow.com/questions/4762788/can-a-class-with-all-private-members-be-a-pod-class/4762944#4762944" target="_blank" rel="noopener">Can a class with all private members be a POD class?</a></li><li>Wikipedia is wrong to say that a POD cannot have members of type pointer-to-member. Or rather, it’s correct for the C++98 wording, but TC1 made explicit that pointers-to-member are POD.</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity问题解决</title>
      <link href="/Unity%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html"/>
      <url>/Unity%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
      
        <content type="html"><![CDATA[<h3 id="Unity相关问题汇总"><a href="#Unity相关问题汇总" class="headerlink" title="Unity相关问题汇总"></a>Unity相关问题汇总</h3><h4 id="Android打包问题"><a href="#Android打包问题" class="headerlink" title="Android打包问题"></a>Android打包问题</h4><h5 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h5><blockquote><p>Unable to list target platforms. Please make sure the android sdk path is correct. See the Console for more details.</p></blockquote><h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><p>1.找到Android SDK安装路径：</p><p>​    windows系统为：C:\Users\YourUsername\AppData\Local\Android\sdk</p><p>​    mac osx为：/Users/username/Library/Android/sdk</p><p>2.将该文件夹下的 tools 文件夹重命名或者直接删除。</p><p>3.下载新的 SDK tool：</p><p>​    windows版本地址：<a href="http://dl-ssl.google.com/android/repository/tools_r25.2.5-windows.zip" target="_blank" rel="noopener">http://dl-ssl.google.com/android/repository/tools_r25.2.5-windows.zip</a></p><p>​    mac osx版本地址：<a href="https://dl.google.com/android/repository/tools_r25.2.3-macosx.zip" target="_blank" rel="noopener">https://dl.google.com/android/repository/tools_r25.2.3-macosx.zip</a></p><p>4.下载后解压到 SDK文件夹下。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Issues </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码赏析之alloc</title>
      <link href="/STL%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%B9%8Balloc.html"/>
      <url>/STL%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%B9%8Balloc.html</url>
      
        <content type="html"><![CDATA[<br> <h4 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h4><blockquote><p>空间配置器分为两级，第一级用于分配大于128字节的内存，第二级用于分配小于等于128字节的内存</p></blockquote><br>  <p>Alloc.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">include &lt;cstdlib&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySTL &#123;</span><br><span class="line"><span class="comment">//空间配置器</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//8字节对齐</span></span><br><span class="line"><span class="keyword">enum</span> &#123; ALIGN = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">//空闲链表最大node为128字节</span></span><br><span class="line"><span class="keyword">enum</span> &#123; MAXBYTES = <span class="number">128</span> &#125;;</span><br><span class="line"><span class="comment">//空闲链表数目</span></span><br><span class="line"><span class="keyword">enum</span> &#123; NFREELISTS = <span class="number">16</span> &#125;; <span class="comment">//(MAXBYTES / ALIGN)</span></span><br><span class="line"><span class="keyword">enum</span> &#123; NOBJS = <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">union</span> obj &#123;</span><br><span class="line"><span class="keyword">union</span> obj* next;</span><br><span class="line"><span class="keyword">char</span> client[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16个空闲链表的head节点</span></span><br><span class="line"><span class="keyword">static</span> obj* free_list[NFREELISTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//内存池空闲部分的开始</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* start_free;</span><br><span class="line"><span class="comment">//内存池空闲部分的结束</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* end_free;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//8字节对齐</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((bytes+ (<span class="keyword">size_t</span>)ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得bytes对应的free_list</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (((bytes)+(<span class="keyword">size_t</span>)ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某一空闲链表空间不足，从内存池中重新分配</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展内存池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span>&amp; nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//分配</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//重新分配</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>Alloc.cpp</p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"../Alloc.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySTL</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span>* alloc::start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* alloc::end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> alloc::heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">alloc::obj* alloc::free_list[NFREELISTS] = &#123;</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* alloc::allocate(<span class="keyword">size_t</span> bytes) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bytes &gt; (<span class="keyword">size_t</span>)MAXBYTES)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> index = FREELIST_INDEX(bytes);</span><br><span class="line">alloc::obj* <span class="built_in">list</span> = free_list[index];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">free_list[index] = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> refill(ROUND_UP(bytes));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果大于MAXBYTES则直接free。</span></span><br><span class="line"><span class="comment">//如果小于MAXBYTES则将对应的node重新加入空闲链表</span></span><br><span class="line"><span class="keyword">void</span> alloc::deallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bytes &gt; (<span class="keyword">size_t</span>)MAXBYTES)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> index = FREELIST_INDEX(bytes);</span><br><span class="line">obj* node = <span class="keyword">static_cast</span>&lt;obj*&gt;(ptr);</span><br><span class="line">node-&gt;next = free_list[index];</span><br><span class="line">free_list[index] = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* alloc::reallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span><br><span class="line">&#123;</span><br><span class="line">deallocate(ptr, old_sz);</span><br><span class="line">ptr = allocate(new_sz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* alloc::refill(<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nobjs = (<span class="keyword">size_t</span>)NOBJS;</span><br><span class="line"><span class="keyword">char</span>* chunk = chunk_alloc(bytes, nobjs);</span><br><span class="line"></span><br><span class="line">obj** my_free_list = <span class="number">0</span>;</span><br><span class="line">obj* current_obj = <span class="number">0</span>;</span><br><span class="line">obj* next_obj = <span class="number">0</span>;</span><br><span class="line">obj* result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nobjs == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">my_free_list = free_list + FREELIST_INDEX(bytes);</span><br><span class="line"><span class="comment">//此时的my_free_list指向分配的chunk内存的index为1的部分</span></span><br><span class="line">*my_free_list = next_obj = (obj*)(chunk + bytes);</span><br><span class="line">result = (obj*)chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>;; i++)</span><br><span class="line">&#123;</span><br><span class="line">current_obj = next_obj;</span><br><span class="line">next_obj = (obj*)((<span class="keyword">char</span>*)next_obj + bytes);</span><br><span class="line"><span class="keyword">if</span> (i == nobjs - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">current_obj-&gt;next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">current_obj = next_obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* alloc::chunk_alloc(<span class="keyword">size_t</span> bytes, <span class="keyword">size_t</span>&amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span>* result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_bytes = bytes * nobjs;</span><br><span class="line"><span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完全可以满意内存要求的情况</span></span><br><span class="line"><span class="keyword">if</span> (bytes_left &gt;= total_bytes)</span><br><span class="line">&#123;</span><br><span class="line">result = start_free;</span><br><span class="line">start_free += total_bytes;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//部分满足内存要求的情况</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= bytes)</span><br><span class="line">&#123;</span><br><span class="line">result = start_free;</span><br><span class="line">nobjs = (<span class="keyword">size_t</span>) (bytes_left / bytes);</span><br><span class="line">total_bytes = bytes * nobjs;</span><br><span class="line">start_free += total_bytes;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全不满足内存要求的情况</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//尝试将剩余的空闲字节加入到空闲链表中</span></span><br><span class="line"><span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">obj** my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">((obj*)start_free)-&gt;next = *my_free_list;</span><br><span class="line">*my_free_list = (obj*)start_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line"><span class="comment">//malloc失败，证明heap不足，尝试从空闲链表中寻找足够大的空间</span></span><br><span class="line"><span class="keyword">if</span> (!start_free)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = bytes; i &lt;= MAXBYTES; i += ALIGN)</span><br><span class="line">&#123;</span><br><span class="line">obj** my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">obj* p = *my_free_list;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p!=0说明找到空间可以分配</span></span><br><span class="line">*my_free_list = p-&gt;next;</span><br><span class="line">start_free = (<span class="keyword">char</span>*)p;</span><br><span class="line">end_free = start_free + i;</span><br><span class="line"><span class="comment">//递归调用以调整nobjs的值</span></span><br><span class="line"><span class="keyword">return</span> chunk_alloc(bytes, nobjs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heap_size += bytes_to_get;</span><br><span class="line">end_free = start_free + bytes_to_get;</span><br><span class="line"><span class="comment">//递归调用以调整nobjs的值</span></span><br><span class="line"><span class="keyword">return</span> chunk_alloc(bytes, nobjs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八皇后问题（回溯法）</title>
      <link href="/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.html"/>
      <url>/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<br> <h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><blockquote><p>在 8X8 的棋盘中放入 8 个皇后，要求任意两个 Queue 不同行，不同列，不同对角线。</p></blockquote><br>  <p>采用回溯法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">include &lt;<span class="built_in">vector</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Grid;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GRID_SIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlaceQueue</span><span class="params">(Grid&amp; grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    grid[row][col] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveQueue</span><span class="params">(Grid&amp; grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    grid[row][col] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSafe</span><span class="params">(Grid&amp; grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//check row</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; GRID_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][col] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check colume</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; GRID_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[row][i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check left bottom</span></span><br><span class="line">    <span class="keyword">int</span> current_row = row;</span><br><span class="line">    <span class="keyword">int</span> current_col = col;</span><br><span class="line">    <span class="keyword">while</span> (--current_row &gt;=<span class="number">0</span> &amp;&amp; --current_col &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[current_row][current_col] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check left top</span></span><br><span class="line">    current_row = row;</span><br><span class="line">    current_col = col;</span><br><span class="line">    <span class="keyword">while</span> (--current_row &gt;= <span class="number">0</span> &amp;&amp; ++current_col &lt; GRID_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[current_row][current_col] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NQueue</span><span class="params">(Grid&amp; grid, <span class="keyword">int</span> colume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colume == GRID_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; GRID_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(IsSafe(grid, colume, i))</span><br><span class="line">        &#123;</span><br><span class="line">            PlaceQueue(grid, colume, i);</span><br><span class="line">            <span class="keyword">bool</span> success = NQueue(grid, colume + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                RemoveQueue(grid, colume, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSolution</span><span class="params">(Grid&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; GRID_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; GRID_SIZE; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Solution row : colume "</span> &lt;&lt; i &lt;&lt; <span class="string">"  "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; grid(GRID_SIZE, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(GRID_SIZE, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(NQueue(grid, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintSolution(grid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution Found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>其中一个 Solution :</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">1</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 属性修饰符总结（水）</title>
      <link href="/Unity%20Shader%20%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%BB%E7%BB%93%EF%BC%88%E6%B0%B4%EF%BC%89.html"/>
      <url>/Unity%20Shader%20%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%BB%E7%BB%93%EF%BC%88%E6%B0%B4%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<br> <p>Unity Shader 属性修饰符总结，方便查阅  </p><br>  <h4 id="属性修饰符简介"><a href="#属性修饰符简介" class="headerlink" title="属性修饰符简介"></a>属性修饰符简介</h4><blockquote><p>在任何属性前面，可以在方括号中指定可选属性。这些属性要么可以被Unity识别，要么可以通过指示自己的MaterialPropertyDrawer类来控制这些属性在 Material Inspector 中的呈现方式。</p></blockquote><br>  <p>Unity识别的属性包含以下几种：</p><ol><li><p>[HideInInspector]：不在 Material Inspector 中显示属性值</p></li><li><p>[NoScaleOffset]：Material Inspector 不会显示具有此属性的纹理属性的 texture tiling/offset 字段</p></li><li><p>[Normal]：表示此纹理需要是一张法线贴图</p></li><li><p>[HDR]：表示此纹理属性需要一张高动态范围（HDR）纹理</p></li><li><p>[Gamma]：对于一个类型为 Float / Vector 的属性，默认情况下不会对它的值作任何转换，但如果在此属性前加上了 [Gamma] 修饰符，则表示它们的值处于 sRGB space，在 shader 中使用时需要先将其值转换到 linear space（转换过程自动完成）。</p></li><li><p>[PerRendererData]：属性用此修饰符修饰时，使用同一个 Material 的各个 Renderer 可以独立的改变该属性值。好处是，1.提升性能；2.在改变某一个 Renderer 的该属性时，Unity 不会自动创建一个新的 Material。缺点是，尽管各个 Renderer 使用同一个材质，但是 MaterialPropertyBlock 会使 Dynamic Batching 失效。使用示例参考下面链接：</p><p><a href="http://thomasmountainborn.com/2016/05/25/materialpropertyblocks/" target="_blank" rel="noopener">PerRenderData的应用</a></p></li><li><p>[Toggle]：材质球调试器, 使用勾选的方式显示</p></li><li><p>[IntRange]：材质球调试器, 滑块拖动时将以整数方式变化</p></li><li><p>[Enum(UnityEngine.Rendering.CullMode)]：材质球调试器, 显示下拉选择, 内置枚举</p></li><li><p>[Enum(MyEnum_0,0,MyEnum_1,1)]：材质球调试器, 显示下拉选择, 自定义枚举</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 内置变量</title>
      <link href="/Unity%20Shader%20%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F.html"/>
      <url>/Unity%20Shader%20%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F.html</url>
      
        <content type="html"><![CDATA[<br> <p>Unity Shader 内置变量总结，方便查阅  </p><br>  <h4 id="转换相关变量（矩阵）"><a href="#转换相关变量（矩阵）" class="headerlink" title="转换相关变量（矩阵）"></a>转换相关变量（矩阵）</h4><br>  <p>类型都是 float4x4  </p><table><thead><tr><th></th><th><strong>Name</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td>模型 &gt;&gt; 投影</td><td>UNITY_MATRIX_MVP</td><td>Current model * view * projection matrix.</td></tr><tr><td>模型 &gt;&gt; 相机</td><td>UNITY_MATRIX_MV</td><td>Current model * view matrix.</td></tr><tr><td>世界 &gt;&gt; 相机</td><td>UNITY_MATRIX_V</td><td>Current view matrix.</td></tr><tr><td>相机 &gt;&gt; 投影</td><td>UNITY_MATRIX_P</td><td>Current projection matrix.</td></tr><tr><td>世界 &gt;&gt; 投影</td><td>UNITY_MATRIX_VP</td><td>Current view * projection matrix.</td></tr><tr><td>MV的转置矩阵</td><td>UNITY_MATRIX_T_MV</td><td>Transpose of model * view matrix.</td></tr><tr><td>MV的逆转置矩阵</td><td>UNITY_MATRIX_IT_MV</td><td>Inverse transpose of model * view matrix.</td></tr><tr><td>模型 &gt;&gt; 世界</td><td>unity_ObjectToWorld</td><td>Current model matrix.</td></tr><tr><td>世界 &gt;&gt; 模型</td><td>unity_WorldToObject</td><td>Inverse of current world matrix.</td></tr></tbody></table><br>  <br>  <h4 id="相机和屏幕相关变量"><a href="#相机和屏幕相关变量" class="headerlink" title="相机和屏幕相关变量"></a>相机和屏幕相关变量</h4><br>  <table><thead><tr><th align="left"><strong>Name</strong></th><th align="left"><strong>Type</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td align="left">_WorldSpaceCameraPos</td><td align="left">float3</td><td>World space position of the camera.</td></tr><tr><td align="left">_ProjectionParams</td><td align="left">float4</td><td><code>x</code> is 1.0 (or –1.0 if currently rendering with a <a href="https://docs.unity3d.com/Manual/SL-PlatformDifferences.html" target="_blank" rel="noopener">flipped projection matrix</a>), <code>y</code> is the camera’s near plane, <code>z</code> is the camera’s far plane and <code>w</code> is 1/FarPlane.</td></tr><tr><td align="left">_ScreenParams</td><td align="left">float4</td><td><code>x</code> is the width of the camera’s target texture in <strong>pixels</strong> , <code>y</code> is the height of the camera’s target texture in pixels, <code>z</code> is 1.0 + 1.0/width and <code>w</code> is 1.0 + 1.0/height.</td></tr><tr><td align="left">_ZBufferParams</td><td align="left">float4</td><td>Used to linearize Z buffer values. <code>x</code> is (1-far/near), <code>y</code> is (far/near), <code>z</code> is (x/far) and <code>w</code> is (y/far).</td></tr><tr><td align="left">unity_OrthoParams</td><td align="left">float4</td><td><code>x</code> is orthographic camera’s width, <code>y</code> is orthographic camera’s height, <code>z</code> is unused and <code>w</code> is 1.0 when camera is orthographic, 0.0 when perspective.</td></tr><tr><td align="left">unity_CameraProjection</td><td align="left">float4x4</td><td>Camera’s projection matrix.</td></tr><tr><td align="left">unity_CameraInvProjection</td><td align="left">float4x4</td><td>Inverse of camera’s projection matrix.</td></tr><tr><td align="left">unity_CameraWorldClipPlanes[6]</td><td align="left">float4</td><td>Camera frustum plane world space equations, in this order: left, right, bottom, top, near, far.</td></tr></tbody></table><br>  <br>  <h4 id="时间相关变量"><a href="#时间相关变量" class="headerlink" title="时间相关变量"></a>时间相关变量</h4><br>  <table><thead><tr><th align="left"><strong>Name</strong></th><th align="left"><strong>Type</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td align="left">_Time</td><td align="left">float4</td><td>Time since level load (t/20, t, tx2, tx3), use to animate things inside the shaders.</td></tr><tr><td align="left">_SinTime</td><td align="left">float4</td><td>Sine of time: (t/8, t/4, t/2, t).</td></tr><tr><td align="left">_CosTime</td><td align="left">float4</td><td>Cosine of time: (t/8, t/4, t/2, t).</td></tr><tr><td align="left">unity_DeltaTime</td><td align="left">float4</td><td>Delta time: (dt, 1/dt, smoothDt, 1/smoothDt).</td></tr></tbody></table><br>  <br>  <h4 id="光照相关变量"><a href="#光照相关变量" class="headerlink" title="光照相关变量"></a>光照相关变量</h4><br>  <blockquote><p>Light参数以不同的方式传递给着色器，具体取决于渲染路径使用，以及在着色器中使用哪个LightMode Pass Tag。  </p></blockquote><br>  <h5 id="前向渲染-（ForwardBase-和-ForwardAdd-pass-类型）"><a href="#前向渲染-（ForwardBase-和-ForwardAdd-pass-类型）" class="headerlink" title="前向渲染 （ForwardBase 和 ForwardAdd pass 类型）"></a>前向渲染 （ForwardBase 和 ForwardAdd pass 类型）</h5><table><thead><tr><th><strong>Name</strong></th><th><strong>Type</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td>_LightColor0 <em>(declared in Lighting.cginc)</em></td><td>fixed4</td><td>Light color.</td></tr><tr><td>_WorldSpaceLightPos0</td><td>float4</td><td>Directional lights: (world space direction, 0). Other lights: (world space position, 1).</td></tr><tr><td>_LightMatrix0 <em>(declared in AutoLight.cginc)</em></td><td>float4x4</td><td>World-to-light matrix. Used to sample cookie &amp; attenuation textures.</td></tr><tr><td>unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0</td><td>float4</td><td><em>(ForwardBase pass only)</em> world space positions of first four non-important point lights.</td></tr><tr><td>unity_4LightAtten0</td><td>float4</td><td><em>(ForwardBase pass only)</em> attenuation factors of first four non-important point lights.</td></tr><tr><td>unity_LightColor</td><td>half4[4]</td><td><em>(ForwardBase pass only)</em> colors of of first four non-important point lights.</td></tr><tr><td>unity_WorldToShadow</td><td>float4x4[4]</td><td>World-to-shadow matrices. One matrix for spot lights, up to four for directional light cascades.</td></tr></tbody></table><br>  <br>  <h5 id="延迟着色和延迟光照相关变量"><a href="#延迟着色和延迟光照相关变量" class="headerlink" title="延迟着色和延迟光照相关变量"></a>延迟着色和延迟光照相关变量</h5><br>  <p>用在 lighting pass 着色器中（定义在UnityDeferredLibrary.cginc中）  </p><table><thead><tr><th align="left"><strong>Name</strong></th><th align="left"><strong>Type</strong></th><th align="left"><strong>Value</strong></th></tr></thead><tbody><tr><td align="left">_LightColor</td><td align="left">float4</td><td align="left">Light color.</td></tr><tr><td align="left">_LightMatrix0</td><td align="left">float4x4</td><td align="left">World-to-light matrix. Used to sample cookie &amp; attenuation textures.</td></tr><tr><td align="left">unity_WorldToShadow</td><td align="left">float4x4[4]</td><td align="left">World-to-shadow matrices. One matrix for spot lights, up to four for directional light cascades.</td></tr></tbody></table><br>  <br>  <h5 id="Vertex-Lit-渲染路径下的相关变量"><a href="#Vertex-Lit-渲染路径下的相关变量" class="headerlink" title="Vertex-Lit 渲染路径下的相关变量"></a>Vertex-Lit 渲染路径下的相关变量</h5><br>  <blockquote><p>关于 Vertex-Lit渲染路径：Vertex Lit路径通常在一个 pass 中渲染每个对象，并为每个顶点计算所有灯光的光照。它是最快的渲染路径，并且拥有最多的硬件支持。但由于光照计算在顶点级别，它不支持大多数逐像素效果：阴影，法线贴图，灯管烘焙（light cookies），高精细度的镜面高光都不被支持。  </p></blockquote><p>最多可为 Vertex pass 类型设置8个灯;始终从最亮的一个开始排序。因此，如果要同时渲染受两个灯影响的对象，则可以在数组中前两个条目。如果影响对象的光线少于8，则其余部分的颜色将设置为黑色。  </p><br>  <table><thead><tr><th align="left"><strong>Name</strong></th><th align="left"><strong>Type</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td align="left">unity_LightColor</td><td align="left">half4[8]</td><td>Light colors.</td></tr><tr><td align="left">unity_LightPosition</td><td align="left">float4[8]</td><td>View-space light positions. (-direction,0) for directional lights; (position,1) for point/spot lights.</td></tr><tr><td align="left">unity_LightAtten</td><td align="left">half4[8]</td><td>Light attenuation factors. <em>x</em> is cos(spotAngle/2) or –1 for non-spot lights; <em>y</em> is 1/cos(spotAngle/4) or 1 for non-spot lights; <em>z</em> is quadratic attenuation; <em>w</em> is squared light range.</td></tr><tr><td align="left">unity_SpotDirection</td><td align="left">float4[8]</td><td>View-space spot light positions; (0,0,1,0) for non-spot lights.</td></tr></tbody></table><br>  <br>  <h4 id="雾和环境（Ambient）相关变量"><a href="#雾和环境（Ambient）相关变量" class="headerlink" title="雾和环境（Ambient）相关变量"></a>雾和环境（Ambient）相关变量</h4><br>  <table><thead><tr><th><strong>Name</strong></th><th><strong>Type</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td>unity_AmbientSky</td><td>fixed4</td><td>Sky ambient lighting color in gradient ambient lighting case.</td></tr><tr><td>unity_AmbientEquator</td><td>fixed4</td><td>Equator ambient lighting color in gradient ambient lighting case.</td></tr><tr><td>unity_AmbientGround</td><td>fixed4</td><td>Ground ambient lighting color in gradient ambient lighting case.</td></tr><tr><td>UNITY_LIGHTMODEL_AMBIENT</td><td>fixed4</td><td>Ambient lighting color (sky color in gradient ambient case). Legacy variable.</td></tr><tr><td>unity_FogColor</td><td>fixed4</td><td>Fog color.</td></tr><tr><td>unity_FogParams</td><td>float4</td><td>Parameters for fog calculation: (density / sqrt(ln(2)), density / ln(2), –1/(end-start), end/(end-start)). <em>x</em> is useful for Exp2 fog mode, <em>y</em> for Exp mode, <em>z</em> and <em>w</em> for Linear mode.</td></tr></tbody></table><br>  <br>  <h4 id="其他变量"><a href="#其他变量" class="headerlink" title="其他变量"></a>其他变量</h4><br>  <table><thead><tr><th align="left"><strong>Name</strong></th><th align="left"><strong>Type</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td align="left">unity_LODFade</td><td align="left">float4</td><td>Level-of-detail fade when using <a href="https://docs.unity3d.com/Manual/class-LODGroup.html" target="_blank" rel="noopener">LODGroup</a>. <em>x</em> is fade (0..1), <em>y</em> is fade quantized to 16 levels, <em>z</em> and <em>w</em> unused.</td></tr><tr><td align="left">_TextureSampleAdd</td><td align="left">float4</td><td>Set automatically by Unity <strong>for UI only</strong> based on whether the texture being used is in Alpha8 format (the value is set to (1,1,1,0)) or not (the value is set to (0,0,0,0)).</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解RenderType</title>
      <link href="/Understanding%20Unity%20Shader%20Tag%20&#39;RenderType&#39;.html"/>
      <url>/Understanding%20Unity%20Shader%20Tag%20&#39;RenderType&#39;.html</url>
      
        <content type="html"><![CDATA[<br><h4 id="RenderType的作用"><a href="#RenderType的作用" class="headerlink" title="RenderType的作用"></a>RenderType的作用</h4><p>李白说：天生我材必有用。那么RenderType的作用到底是什么呢？</p><p>贴一段Unity对RenderType的描述：</p><blockquote><p>RenderTypetag categorizes shaders into several predefined groups, e.g. is is an opaque shader, or an alpha-tested shader etc. This is used by <a href="https://docs.unity3d.com/Manual/SL-ShaderReplacement.html" target="_blank" rel="noopener">Shader Replacement</a> and in some cases used to produce <a href="https://docs.unity3d.com/Manual/SL-CameraDepthTexture.html" target="_blank" rel="noopener">camera’s depth texture</a>. </p></blockquote><p>可知，RenderType可以在替代渲染中用到，也可以用来生成相机的深度纹理。</p><br><h4 id="使用RenderType的方法"><a href="#使用RenderType的方法" class="headerlink" title="使用RenderType的方法"></a>使用RenderType的方法</h4><p>替换渲染通过使用 Camera.RenderWithShader 或者 Camera.SetReplacementShader 两个方法进行，这两个方法都接受两个参数，分别为 replacementShader 和 “替换标签” replacementTag，进行替换渲染时，场景中物体仍然使用他们的材质，但实际用于渲染的 Shader 已经改变，至于使用什么 Shader 进行渲染则由第二个参数 replacementTag 决定。规则如下：</p><ol><li><p>如果 replacementTag 为空，则场景中所有物体使用 replacementShader 进行渲染。</p></li><li><p>如果 replacementTag 不为空，将 replacementTag 的值记为 rtValue，继续进行以下验证：</p><ol><li><p>查询物体原有 Shader 中是否存在名为 rtValue 的 tag。如果不存在，该物体将不被渲染。</p></li><li><p>查询 replacementShader 中是否存在名为 rtValue 的 tag，且该 tag 的值和物体原有 Shader 中的名为 rtValue 的 tag 的值是否相同，如果不存在该 tag 或 tag 的值不相同，则该物体不被渲染。</p><p>当同时满足以上两个条件时，物体的原有 Shader 会被替换为 replacementShader 中对应的那个 SubShader（即 tag 值相同的 Shader ) 进行渲染。</p></li></ol></li></ol><br><h4 id="Unity中RenderType的默认值"><a href="#Unity中RenderType的默认值" class="headerlink" title="Unity中RenderType的默认值"></a>Unity中RenderType的默认值</h4><ol><li>Opaque：带有该标签的 ReplacementShader 可用于替换大多数 Shader（法线着色器、自发光着色器、反射着色器、地形着色器）</li><li>Transparent：用于半透明着色器</li><li>TransparentCutout：蒙面透明着色器</li><li>Background：天空盒子</li><li>Overlay：GUITexture、光晕着色器、闪光着色器</li><li>TreeOpaque：地形引擎中的树皮</li><li>TreeTransparentCutout：地形引擎中的树叶</li><li>TreeBillboard：地形引擎中的广告牌树</li><li>Grass：地形引擎中的草</li><li>GrassBillboard：地形引擎中的广告牌草</li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语学习之品歌词</title>
      <link href="/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%93%81%E6%AD%8C%E8%AF%8D.html"/>
      <url>/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%93%81%E6%AD%8C%E8%AF%8D.html</url>
      
        <content type="html"><![CDATA[<p>鬼灭之刃    《红莲华》</p><p>Tsuyoku nareru riyū o shitta</p><p>強くなれる理由を知った</p><p>我知道为什么我会坚强</p><p>Boku o tsurete susume</p><p>僕を連れて　進め</p><p>带着我 前进吧</p><p>Doro-darake no sōmatō ni you</p><p>泥だらけの走馬灯に酔う</p><p>沉醉于泥泞不堪的走马灯</p><p>Kowabaru kokoro furueru te wa</p><p>強張る心　震える手は</p><p>逞强的心 颤抖的手</p><p>sekai ni  u chi no me sa re te<br>世界  に  打 ち  の め  さ れ て<br>被世界击败</p><p>ma ke ru i mi o shi t ta<br>負 け る 意味  お し っ た<br>明白了失败的意义</p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语假名之图像编码</title>
      <link href="/%E6%97%A5%E8%AF%AD%E5%81%87%E5%90%8D%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BC%96%E7%A0%81.html"/>
      <url>/%E6%97%A5%E8%AF%AD%E5%81%87%E5%90%8D%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BC%96%E7%A0%81.html</url>
      
        <content type="html"><![CDATA[<h4 id="我这一生，尽是可耻之事"><a href="#我这一生，尽是可耻之事" class="headerlink" title="我这一生，尽是可耻之事"></a>我这一生，尽是可耻之事</h4><p>​                        – 太宰治</p><h4 id="我这一篇，尽是粗鄙之语"><a href="#我这一篇，尽是粗鄙之语" class="headerlink" title="我这一篇，尽是粗鄙之语"></a>我这一篇，尽是粗鄙之语</h4><p>​                        – エロ老师</p><p>以下为本人日语学习过程中为记忆假名而使用的荒诞的方法，可能不会对除我之外的许多人有帮助，<br>并且根据别人的经验之谈，是不太建议以这种看起来较为投机取巧的方式记忆假名的，因此各位看此篇<br>文章时浅尝辄止即可。如果此文对你产生了一些微小的帮助，本人不胜荣幸；如果此文令你感到不适，<br>请速速逃离。</p><h4 id="第一行假名"><a href="#第一行假名" class="headerlink" title="第一行假名"></a>第一行假名</h4><p>罗马音：                  a   i   u   e  o</p><p>平假名：                 あ  い  う  え  お</p><p>片假名：                 ア  イ  ウ  エ  オ</p><h4 id="第二行假名"><a href="#第二行假名" class="headerlink" title="第二行假名"></a>第二行假名</h4><p>罗马音：                 ka   ki   ku   ke   ko    </p><p>平假名：                 か  き  く  け  こ</p><p>片假名：                 カ  キ  ク  ケ  コ</p><p>ki：撑杆跳成功起飞<br>ko：小括号、中括号</p><h4 id="第三行假名"><a href="#第三行假名" class="headerlink" title="第三行假名"></a>第三行假名</h4><p>罗马音：                 sa   shi   su   se   so</p><p>平假名：                 さ  し  す  せ  そ</p><p>片假名：                 サ  シ  ス  セ  ソ</p><p>sa：撑杆跳失败摔骨折<br>shi：姜子牙溪上钓鱼愿者上钩</p><h4 id="第四行假名"><a href="#第四行假名" class="headerlink" title="第四行假名"></a>第四行假名</h4><p>罗马音：                ta     chi   tsu     te   to</p><p>平假名：                た　ち　つ　て　と</p><p>片假名：                タ    チ　ツ    テ　ト</p><p>ta：太阳变夕阳照在塔上<br>chi：５千7<br>tsu：屠夫把川少勾过来吃了<br>te：与chi对应<br>to：上山下乡拔萝卜</p><h4 id="第五行假名"><a href="#第五行假名" class="headerlink" title="第五行假名"></a>第五行假名</h4><p>罗马音：                na     ni      nu   ne    no</p><p>平假名：                な　に　ぬ　ね　の</p><p>片假名：                ナ    ニ　ヌ    ネ　ノ</p><p>na：四爷废了叶赫那拉氏变寡人<br>ni：立人+二 –》 仁<br>nu：奴隶<br>ne：有权有势的快乐<br>no：91罗先生</p><h4 id="第六行假名"><a href="#第六行假名" class="headerlink" title="第六行假名"></a>第六行假名</h4><p>罗马音：                ha     hi    hu　he   ho</p><p>平假名：                は　ひ　ふ　へ　ほ</p><p>片假名：                ハ    ヒ　フ    ヘ　ホ</p><p>ha：哈尔滨房东押一付八<br>hi：荆轲say　hi匕首现，秦王绕柱而环走<br>hu：小夫被胖虎一巴掌扇飞<br>hehe：女神今天又对我呵呵笑了真开心<br>ho：钻木取火</p><h4 id="第七行假名"><a href="#第七行假名" class="headerlink" title="第七行假名"></a>第七行假名</h4><p>罗马音：                ma     mi    mu　me    mo</p><p>平假名：                ま　み　む  め　も</p><p>片假名：                マ    ミ　ム    メ　モ</p><p>ma：厉兵秣马修断矛<br>mi：阿尔法狗抽出3米大刀<br>mu：克己废公慕容复<br>me：女神X我么么哒<br>mo：首尾不相顾 毛</p><h4 id="第八行假名"><a href="#第八行假名" class="headerlink" title="第八行假名"></a>第八行假名</h4><p>罗马音：                ya     i   yu      e   yo</p><p>平假名：                や　い　ゆ　え　よ</p><p>片假名：                ヤ    イ　ユ    エ　ヨ</p><p>yu：周幽王怀揽褒姒城上戏诸侯<br>yo：上寻下yo</p><h4 id="第九行假名"><a href="#第九行假名" class="headerlink" title="第九行假名"></a>第九行假名</h4><p>罗马音：                ra     ri    ru　re    ro</p><p>平假名：                ら  り  る  れ  ろ</p><p>片假名：                ラ    リ　ル  レ　ロ</p><p>ra：la是第五个音<br>ri：帅的让女神失去卫生巾<br>ru：大胸小三怀孕生子成功上位<br>re：札幌一夜东京热，回家失去另一半<br>ro：ro萝莉有3好：身轻体柔易工口</p><h4 id="第十行假名"><a href="#第十行假名" class="headerlink" title="第十行假名"></a>第十行假名</h4><p>罗马音：                wa     i     u     e     wo</p><p>平假名：                わ　い　う　え　を</p><p>片假名：                ワ    イ　ウ    エ　ヲ</p><p>wa:娃读一半书，仅得一半屋（ウ）<br>wo：我一脚踩空，是祸非福（F）</p><p>n<br>ん<br>ン</p><p>n：伸长了脖子</p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>template</title>
      <link href="/template.html"/>
      <url>/template.html</url>
      
        <content type="html"><![CDATA[<p>This is the template post.</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
